# # [ ] 와이즈넛 코테 복기
# MEMO: 난이도는 '하'였던 듯 문제가 길거나 어려운 문제는 없었다..

# # [1] 

# # 문제 설명
# # 복리법은 전 단계까지의 원리합계에 대해서 이율을 적용하는 방법입니다. 다음은 원 금 100만 원에 월 이율 10%로 복리법을 적용한 경우를 나타내는 표입니다.
# # 복리 계산
# # 원금
# # 1달 후
# # 2달 후
# # 3달 후
# # 1,000,000원
# # 1,000,000원 + 1,000,000 x 0.1 = 1,100,000원
# # 1,100,000원 + 1,100,000 x 0.1 = 1,210,000원
# # 1,210,000원 + 1,210,000 x 0.1 = 1,331,000원
# # m달 후
# # 1,000,000 x (1 + 0.1)” 원
# # 복리법을 적용하여 원금 p 원이 m 달 후에 d 원 이상이 되도록 하는 최소 월 이율 K% 를 찾으려고 합니다(단, k는 가능한 k 값 중 가장 작은 정수).
# # 원금 P, 달의 수 m, 목표 금액 d가 매개변수로 주어질 때, 복리법을 적용하여 원금 p 원이 m 달 후에 d 원 이상이 되도록 하는 최소 월 이율 K%를 return 하도록 solution 함수를 완성해주세요. 단, 매달 이자는 소수점 이하를 버린 값이 더해진다고 가정합니다.

# # 제한사항

# # • 원금 p는 1,000,000 이상 1,000,000,000 이하의 자연수이며, 100만 단위로 만 주어집니다.

# # • 목표 달 m은 1 이상 20 이하의 자연수입니다.

# # • 목표 금액 d는 1,000,000 이상 1,000,000,000 이하의 자연수(ps d s 0*2" ) 이며, 100만 단위로만 주어집니다.

# # • k로 가능한 값 중 가장 작은 정수를 return 하면 됩니다.
# # • return 값이 0 이상 100 이하로 나오도록 매개변수들이 주어집니다.
# # 입출력 예

# # m
# # d
# # result
# # 10000000
# # 9
# # 13000000
# # 3
# # 1000000
# # 3
# # 1000000
# # 0

# def calculate(p,m,d,k):
#     return p*(1+(k*0.01))**m

# def solution(p,m,d):
#     result = 0
    
#     for k in range(100):
#         result = calculate(p,m,d,k)
#         if result >= d:
#             break
#     return k

# # GPT 
# import math

# # 매달 이율을 반영하여 소수점 이하를 버린 값을 계산하는 함수
# def calculate(p, m, k):
#     for _ in range(m):
#         p += math.floor(p * (k / 100))
#     return p

# def solution(p, m, d):
#     low, high = 0, 100  # 이율 범위 설정
    
#     while low < high:
#         mid = (low + high) // 2
#         if calculate(p, m, mid) >= d:
#             high = mid  # 목표 금액을 넘겼다면 이율을 더 낮춰서 탐색
#         else:
#             low = mid + 1  # 목표 금액에 못 미쳤다면 이율을 더 높여서 탐색
    
#     return low


# # [2]
# # 정확성 시간 제한 / 효율성 시간 제한 / 메모리 제한
# # 10초/ 언어별로 작성된 정답 코드의 실행 시간의 적정 배수 / 2GB
# # 문제 설명
# # 자연수가 적힌 2* N장의 카드묶음을 가지고 있습니다. 카드묶음에는 같은 숫자가 적 힌 카드가 2장씩 포함되어 있습니다. 어느 날 카드 1장을 잃어버렸습니다. 2*N - 1길 이의 카드 배열(cards)이 입력으로 주어질 때 잃어버린 카드에 적힌 숫자를 return 하도록 Solution 함수를 완성해 주세요.
# # 제한사항
# # • 카드 개수 N : 1,000,000 이하의 자연수(단, 홀수로 주어집니다.)
# # • 카드에 적혀 있는 숫자 범위 : 100,000,000 이하의 자연수
# # cards
# # answer
# # [1, 3,2, 2, 5, 5, 기
# # 3
# # 입출력 예
# # 입출력 예 설명
# # 입출력 예 #1
# # 1은 2개, 2는 2개, 5는 2개, 3은 1개가 들어있으므로 없어진 카드는 3이 적힌 카드입 니다.
# from collections import Counter

# def solution(cards):
#     counter = Counter(cards)
    
#     return counter.most_common()[-1][0]

# # GPT ^= 
# def solution(cards):
#     missing_card = 0
#     for card in cards:
#         missing_card ^= card  # XOR 연산을 통해 잃어버린 카드 찾기
#     return missing_card



# # [3]
# # a2+ b2 = c2을 만족하게 하는 세 개의 자연수 a, b, c를 피타고라스의 수 또는 피타 고라스의 세 쌍(Pythagorean triple)이라고 합니다. 세 개의 자연수 a, b, c( a<=b<=CC=500,000) 중 b 값이 매개변수로 주어 질 때, c값을 return 하도록 solution 함수를 작성하세요.
# # 제한사항
# # 1. 만족하는 C 값이 없다면 -1을 return 해주세요.
# # 2. 만족하는 c 값이 여러 개라면 그 중 제일 작은 수를 return해주세요.
# # 입출력 예
# # 1 b = 4 , result = 5
# # 2 b = 12 , result = 13
# # 3 b = 5 , result = -1
# # 입출력 예 설명
# # 입출력 예 #1
# # a = 3, b = 4, C = 5가 피타고라스의 수가 됩니다.
# # 입출력 예 #2
# # a= 5, b = 12, C = 13 가 피타고라스의 수가 됩니다.
# # 입출력 예 #3
# # b가 5이면 피타고라스의 수를 만족하는 a, c는 존재하지 않습니다.

# def solution(b): 
#     for i in range(1, 5001):
#         c = (i**2 + b**2)**0.5
#         a = i
#         if c < i+b and c == int(c) and (a <=b and b<=c):
#             return (a**2 + b **2)**0.5
#     return -1

# def solution(b):
#     # a는 1부터 b까지의 범위에서 탐색
#     for a in range(b):
#         c__square = a**2+ b**2
#         c = int(c__square**0.5)

#         if c**2 == c__square:
#             return c
    
#     # 조건을 만족하는 값이 없으면 -1 반환
#     return -1 

# # GPT 
# def solution(b):
#     # a는 1부터 b까지의 범위에서 탐색
#     for a in range(1, b + 1):  # a는 b까지 가능
#         c_square = a**2 + b**2  # 피타고라스 정리 적용
#         c = int(c_square**0.5)   # c 값 계산 (정수화)
        
#         # c가 c_square의 제곱근인지 확인 (즉, 정수여야 함)
#         if c**2 == c_square:
#             return c  # 조건을 만족하면 c 반환
    
#     # 조건을 만족하는 값이 없으면 -1 반환
#     return -1

        
# # [4]

# # 임의의 자연수 N이 주어질 때 각 자리의 숫자를 정렬하려고 합니다. 예를 들어 주어진 숫자 N = 2613인 경우 각 자릿수를 오름차순으로 정렬하면 1236이 되며, 내림차순 으로 정렬하면 6321이 되고, 두 숫자의 합은 7557이 됩니다. 임의의 자연수 N이 매 개변수로 주어질 때 N의 각 자릿수를 오름차순으로 정렬한 수와 내림차순으로 정렬한 수의 합을 return 하도록 Solution 함수를 완성해 주세요.
# # 제한사항
# # • N은 1이상 10억 이하의 자연수입니다.
# # 입출력 예
# # N
# # result
# # 2613
# # 7557
# # 33285
# # 108690
# # 입출력 예 설명
# # 입출력 예 #1
# # 2613의 각 자릿수를 오름차순 정렬하면 1236이며, 내림차순 정렬하면 6321입니다.
# # 1236+ 6321= 7557입니다.
# # 입출력 예 #2
# # 33285의 각 자릿수를 오름차순 정렬하면 23358이며, 내림차순 정렬하면 85332입 니다. 23358+ 85332= 108690입니다.

# def solution(N):
#     return int(''.join(sorted(str(N))))  + int(''.join(sorted(str(N),reverse= True)))


# 화살표를 옮겨가며 KBS1,2 인덱스 찾기 
# KBS 찾으면 index- 0 index- 1

# DFS로 1,3 선택 재귀로 반복 . 종료 시점은 stones > N -> 그 직전 사람이 마지막 돌을 가져감
# 재귀 횟수가 홀수면 SK, 짝수면 CY
        
    
# [ ] LIG 넥스원 코딩테스트
# MEMO: 난이도는 '중상'?정도였다. 문제 이해가 어려웠지만, 구현은 어렵지 않았던듯 
# MEMO: 문제를 예제와 같이 완벽히 이해해서 슈드코드로 알고리즘 먼저 짜고 코딩 시작하기-> 예외 상황, 최적화 고민

# [1] 1~num1까지 존재하는 a와 1~ num2까지 존재하는 b가 있다. c = a*b가 된다.
# NOTE: A.issubset(B), A가 B의 부분 집합인가? 즉 A의 원소가 B가 모두 속하나 체크 후 True'/False 반환
# C 에 존재하는 숫자가 모두 a,b에 존재하는 (a,b)의 순서쌍의 수를 구해라 
# 주어진 문제를 해결하기 위한 파이썬 코드는 두 변수 a와 b의 범위에서 곱한 결과인 c에 포함된 모든 숫자가 a와 b의 범위에 포함된 숫자인지 확인하는 방식으로 구현할 수 있습니다. 이 문제는 숫자와 그 곱셈의 결과에서 각 자릿수를 비교하는 문제로 볼 수 있습니다.

def count_valid_pairs(num1, num2):
    count = 0
    
    # num1과 num2의 범위에서 a와 b를 각각 선택
    for a in range(1, num1 + 1):
        for b in range(1, num2 + 1):
            c = a * b
            # c를 문자열로 변환하여 각 자릿수를 리스트로 만듦
            c_digits = set(str(c))
            # a와 b도 문자열로 변환하여 자릿수 리스트를 만듦
            ab_digits = set(str(a) + str(b))
            
            # c의 모든 자릿수가 a 또는 b에 존재하는지 확인
            if c_digits.issubset(ab_digits):
                count += 1
    
    return count

# 예시 실행
a = 32
b = 24
result = count_valid_pairs(a, b)
print(f"총 {result}개의 순서쌍이 존재합니다.")

# [2] 열기구 승하차 

# [3] 다익스트라 최단거리 알고리즘 (양방향 그래프)