# [ ] Dynamic Programming
# https://youtu.be/5Lu34WIx2Us?si=ezrPX_DjqsfO6M94

# [ ] 다이나믹 프로그래밍이란?
# 한 번 해결한 문제를 다시 해결하지 않아 시간 복잡도를 획기적으로 줄이는 것이 포인트 !
# 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
# 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
# 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 (탑 다운과 보텀 업)으로 구성

# [ ] 다이나믹 프로그래밍의 조건 
# 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있다 ! 
# 1. 최적 부분 구조 (Optimal Substructure) -> 탑 다운
# 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
# 2. 중복되는 부분 문제 (Overlapping Subproblem ) -> 보텀업
# 동일한 작은 문제를 반복적으로 해결하는 문제 

# [ ] 피보나치 수열 
# 피보나치 수열처럼 점화식으로 표현 가능할 때는 간단히 점화식으로 풀이할 수 있다 !!

# 재귀함수로 피보나치 함수 구현 
'''
import time 

def fibo(n):
    if n == 1 or n == 2 : # 재귀함수 구현 시 종료 시점 명확히 !, 1,2번째 수는 1이므로 1로 반환하여 종료
        return 1
    return fibo(n-1) + fibo(n-2)

start_time = time.time()
print(fibo(40))
end_time = time.time()

print(f"재귀함수 수행시간 : {end_time - start_time}")

'''
# NOTE: 피보나치 함수를 재귀함수로 표현했을 때 문제 
# 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다.
# 즉, n이 조금만 커져도 복잡도가 기하급수적으로 커짐 
# 그리고 같은 값이 피보함수가 (예: f(2)여러번 연산) 여러번 호출 -> 중복되는 문제 
# 즉 똑같은 함수의 값을 저장해두고 (f(2)=4라고 기록하고 연산 없이 4의 값 활용) 가져다 쓰면 
# 되는데 비효율적으로 같은 연산 반복 -> 수행시간 측면에서 비효율

# [ ] Top-down 방식 : 메모이제이션(Memoization)
# 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나
# 한 번 계산한 결과를 메모리 공간에 메모하는 기법
# 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
# 값을 기록해 놓는다는 점에서 캐싱이라고도 한다.

# NOTE : 탑다운 VS 보텀업
# 탑 다운은(메모이제이션)방식 : 하향식으로도 부름

# 작은 문제들을 재귀함수로 해결하여 큰 문제도 해결하는 방식 예) 피보나치 함수
# 이 과정에서 한번 계산된 값을 기억하기 위해 메모이제이션 기법을 활용 -> 똑같은 연산 반복문제 해결

# 보텀업 방식 : 상향식으로도 부름 
# 다이나믹 프로그래밍의 전형적인 방식

# 작은 문제들을 반복문을 활용하여서 반복하여 해결하는 방식 
# 먼저 계산했던 값들을 활용하여 다음 문제를 해결하는 것이 특징


# [ ] 메모이제이션 == 다이나믹 프로그래밍?
# 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님. 다른 개념이다.
# 엄밀히 말하면 메모이제이션은 이미 계산된 결과를 일시적으로 기록해두고, 활용하는 넓은 개념을 의미.
# 즉, 한 번된 결과를 담아두기만 한다면 '메모이제이션 기법을 활용했다, 캐시를 사용했다'고 표현함

# [1] 탑다운 (메모이제이션)
'''
import time

D = [0]*100 # 계산된 값을 저장하는(메모이제이션을 위한) 리스트 

def fibo(n):
    if n==1 or n==2: # 종료 조건 
        return 1
    if D[n] != 0 : # 한 번 계산된 값이라면, 연산하지않고 저장된 결과값 활용
        return D[n]
    # 처음 계산되는 값이라면 리스트에 연산 값을 저장하고 연산값 반환
    D[n] = fibo(n-1) + fibo(n-2)
    return D[n]
sstart_time = time.time()
print(fibo(40))
eend_time = time.time()

print(f'탑다운 수행시간: {eend_time-sstart_time}')
'''
# 일반 재귀함수 방식과 탑다운 다이나믹 방식 연산 시간 비교 
import time
# 일반 재귀함수 
def re_fibo(n):
    if n == 1 or n ==2 :
        return 1
    return re_fibo(n-1) + re_fibo(n-2)
    
# 탑다운 방식
D = [0]*100
def fibo(n):
    if n ==1 or n==2 :
        return 1
    if D[n] != 0:
        return D[n]
    D[n] = fibo(n-1) + fibo(n-2)
    
    return D[n]

start1 = time.time()
re_fibo(40)
end1 = time.time()
print(f"재귀: {end1-start1}s")

start2 = time.time()
fibo(40)
end2 = time.time()
print(f"다이나믹: {end2-start2}s")

