# [ ] Dynamic Programming
# https://youtu.be/5Lu34WIx2Us?si=ezrPX_DjqsfO6M94

# [ ] 다이나믹 프로그래밍이란?
# 한 번 해결한 문제를 다시 해결하지 않아 시간 복잡도를 획기적으로 줄이는 것이 포인트 !
# 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
# 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
# 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 (탑 다운과 보텀 업)으로 구성

# [ ] 다이나믹 프로그래밍의 조건 
# 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있다 ! 
# 1. 최적 부분 구조 (Optimal Substructure) : 
# 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
# 2. 중복되는 부분 문제 (Overlapping Subproblem  )
# 동일한 작은 문제를 반복적으로 해결하는 문제 

# [ ] 피보나치 수열 
# 피보나치 수열처럼 점화식으로 표현 가능할 때는 간단히 점화식으로 풀이할 수 있다 !!

# 재귀함수로 피보나치 함수 구현 
'''
import time 

def fibo(n):
    if n == 1 or n == 2 : # 재귀함수 구현 시 종료 시점 명확히 !, 1,2번째 수는 1이므로 1로 반환하여 종료
        return 1
    return fibo(n-1) + fibo(n-2)

start_time = time.time()
print(fibo(40))
end_time = time.time()

print(f"수행시간 : {end_time - start_time}")
'''

# NOTE: 피보나치 함수를 재귀함수로 표현했을 때 문제 
# 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다.
# 즉, n이 조금만 커져도 복잡도가 기하급수적으로 커짐 
# 그리고 같은 값이 피보함수가 (예: f(2)여러번 연산) 여러번 호출 -> 중복되는 문제 
# 즉 똑같은 함수의 값을 저장해두고 (f(2)=4라고 기록하고 연산 없이 4의 값 활용) 가져다 쓰면 
# 되는데 비효율적으로 같은 연산 반복 -> 수행시간 측면에서 비효율
