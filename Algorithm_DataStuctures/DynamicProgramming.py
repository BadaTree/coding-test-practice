# [ ] Dynamic Programming
# https://youtu.be/5Lu34WIx2Us?si=ezrPX_DjqsfO6M94

# [ ] 다이나믹 프로그래밍이란?
# 한 번 해결한 문제를 다시 해결하지 않아 시간 복잡도를 획기적으로 줄이는 것이 포인트 !
# 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
# 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
# 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 (탑 다운과 보텀 업)으로 구성

# [ ] 다이나믹 프로그래밍의 조건 
# 다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있다 ! 
# 1. 최적 부분 구조 (Optimal Substructure) -> 탑 다운
# 큰 문제를 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아서 큰 문제를 해결할 수 있다.
# 2. 중복되는 부분 문제 (Overlapping Subproblem ) -> 보텀업
# 동일한 작은 문제를 반복적으로 해결하는 문제 

# [ ] 피보나치 수열 
# 피보나치 수열처럼 점화식으로 표현 가능할 때는 간단히 점화식으로 풀이할 수 있다 !!

# 재귀함수로 피보나치 함수 구현 
'''
import time 

def fibo(n):
    if n == 1 or n == 2 : # 재귀함수 구현 시 종료 시점 명확히 !, 1,2번째 수는 1이므로 1로 반환하여 종료
        return 1
    return fibo(n-1) + fibo(n-2)

start_time = time.time()
print(fibo(40))
end_time = time.time()

print(f"재귀함수 수행시간 : {end_time - start_time}")

'''
# NOTE: 피보나치 함수를 재귀함수로 표현했을 때 문제 
# 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다.
# 즉, n이 조금만 커져도 복잡도가 기하급수적으로 커짐 
# 그리고 같은 값이 피보함수가 (예: f(2)여러번 연산) 여러번 호출 -> 중복되는 문제 
# 즉 똑같은 함수의 값을 저장해두고 (f(2)=4라고 기록하고 연산 없이 4의 값 활용) 가져다 쓰면 
# 되는데 비효율적으로 같은 연산 반복 -> 수행시간 측면에서 비효율

# [ ] Top-down 방식 : 메모이제이션(Memoization)
# 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나
# 한 번 계산한 결과를 메모리 공간에 메모하는 기법
# 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
# 값을 기록해 놓는다는 점에서 캐싱이라고도 한다.

# NOTE : 탑다운 O(N) VS 보텀업
# 탑 다운은(메모이제이션)방식 : 하향식으로도 부름

# 작은 문제들을 재귀함수로 해결하여 큰 문제도 해결하는 방식 예) 피보나치 함수
# 이 과정에서 한번 계산된 값을 기억하기 위해 메모이제이션 기법을 활용 -> 똑같은 연산 반복문제 해결

# 보텀업 방식 : 상향식으로도 부름 
# 다이나믹 프로그래밍의 전형적인 방식

# 작은 문제들을 반복문을 활용하여서 반복하여 해결하는 방식 
# 먼저 계산했던 값들을 활용하여 다음 문제를 해결하는 것이 특징


# [ ] 메모이제이션 == 다이나믹 프로그래밍?
# 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님. 다른 개념이다.
# 엄밀히 말하면 메모이제이션은 이미 계산된 결과를 일시적으로 기록해두고, 활용하는 넓은 개념을 의미.
# 즉, 한 번된 결과를 담아두기만 한다면 '메모이제이션 기법을 활용했다, 캐시를 사용했다'고 표현함

# [1] 탑다운 (메모이제이션)
'''
import time

D = [0]*100 # 계산된 값을 저장하는(메모이제이션을 위한) 리스트 

def fibo(n):
    if n==1 or n==2: # 종료 조건 
        return 1
    if D[n] != 0 : # 한 번 계산된 값이라면, 연산하지않고 저장된 결과값 활용
        return D[n]
    # 처음 계산되는 값이라면 리스트에 연산 값을 저장하고 연산값 반환
    D[n] = fibo(n-1) + fibo(n-2)
    return D[n]
sstart_time = time.time()
print(fibo(40))
eend_time = time.time()

print(f'탑다운 수행시간: {eend_time-sstart_time}')
'''
# 일반 재귀함수 방식과 탑다운 다이나믹 방식 연산 시간 비교 
'''
import time
# 일반 재귀함수 
def re_fibo(n):
    if n == 1 or n ==2 :
        return 1
    return re_fibo(n-1) + re_fibo(n-2)
    
# 탑다운 방식
D = [0]*100
def fibo(n):
    if n ==1 or n==2 :
        return 1
    if D[n] != 0:
        return D[n]
    D[n] = fibo(n-1) + fibo(n-2)
    
    return D[n]

start1 = time.time()
re_fibo(40)
end1 = time.time()
print(f"재귀: {end1-start1}s")

start2 = time.time()
fibo(40)
end2 = time.time()
print(f"다이나믹: {end2-start2}s")

'''

# [2] 보텀업 방식 

# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
D = [0]*100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
D[1],D[2] = 1, 1
n = 40

# 반복문으로 구현한 보텀업 방식 피보나치함수
for i in range(3,n+1):
    D[i] = D[i-1]+D[i-2]
    
print(D[n])

# [ ] 다이나믹 프로그래밍 VS 분할 정복 
# 다이나믹 프로그래밍과 분할 정복 모두 최적 부분 구조를 가질 때 사용할 수 있다.
# 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황

# NOTE: 다이나믹 프로그래밍과 분할 정복의 차이점은 부분 문제의 중복 !!
# 다이나믹은 작은 문제들이 종종 중복되며 영향을 미침, 분할 정복은 동일한 문제가 반복되지 않는다.


# [ ] 다이나믹 프로그래밍 문제에 접근하는 방법
# 주어진 문제가 다이나믹 프로그래밍 유형임을 파악하는 것이 중요.
# 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있다.
# 다른 알고리즘으로 풀이가 떠오르지 않는다면 다이나믹을 고려
# 작은 문제 연산으로 큰 문제를 해결할 수 있으며, 그 과정에서 같은 문제 연산이 반복된다면? -> 다이나믹프로그래밍 고려 

# 일단 재귀함수로 비효율적인 완전탐색 풀이를 작성한 다음, 메모이제이션 방식을 적용하는 것도 방법 !!

